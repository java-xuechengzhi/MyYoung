//
// Created by Xue on 2021/5/31.
//

#include<stdio.h>
#include <stdlib.h>

int main(void)
{
    int count, *array; /*count是一个计数器，array是一个整型指针，也可以理解为指向一个整型数组的首地址*/

    if ((array=(int *) malloc(10 * sizeof(int))) == NULL)//把类型强制转换为int 申请内存空间 10个int的空间
        //一个int大小是sizeof(int)
    {
        printf("不能成功分配存储空间。");
        exit(1); //强制结束程序
    }

    for (count = 0; count < 10; count++) { /*给数组赋值*/
        array[count] = count;
    }

    for (count = 0; count < 10; count++) { /*打印数组元素*/
        printf("%2d", array[count]);
    }

    free(array);  //刚刚没有进行释放内存

    return 0;

}
/**静态内存的数量在编译时是固定的，在运行期间也不会改变，
自动变量使用的内存数量在程序执行期间自动增加或减少，但是动态内存分配内存的数量只会增加，除非使用free函数进行释放
        它创建了指针array，并调用了malloc函数进行内存分配了（10* 4(int) ）40个字节的内存，假设，如代码注释所示，
遗漏了free,当函数结束时，作为自动变量的指针array也会消失，但是它所指向的40个字节的内存却仍然存在，
由于array指针已被销毁，所以无法访问这块内存，它也不能被重复使用，因为代码中没有调用free函数释放这块内存，
如果是一个函数，当第二次调用它时，它又创建了array指针，并调用malloc分配40个字节的内存，第一次调用的40个字节的内存已不可用，
所以malloc函数分配了另外的内存，当函数结束时该内存也无法被访问和再使用，如果循环要进行1000次,那么每一次的调用都会分配内存，
持续增加，实际上，等不到程序结束，内存早已被耗尽，这类问题被称为内存泄漏，所以 为防止这类问题的发生，
必须要在动态内存分配函数后加上free函数释放内存。
 */